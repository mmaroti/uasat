/**
 * Copyright (C) Miklos Maroti, 2015-2017
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
 * Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

package org.uasat.math;

import java.util.*;

import org.uasat.core.*;

public class StructuralClones {
	private final SatSolver<?> solver;
	private final int size;
	private final List<PartialOperation<Boolean>> partialops;
	private GaloisConn<Boolean> galois;
	public boolean trace = false;

	public StructuralClones(int size) {
		this(size, SatSolver.getDefault());
	}

	public StructuralClones(int size, SatSolver<?> solver) {
		assert size >= 1 && solver != null;

		this.size = size;
		this.solver = solver;

		partialops = new ArrayList<PartialOperation<Boolean>>();
		galois = GaloisConn.wrap(Tensor.constant(new int[] { 0, 0 }, Boolean.FALSE));
	}

	public int getSize() {
		return size;
	}

	public List<PartialOperation<Boolean>> getPartialOps() {
		return partialops;
	}

	public GaloisConn<Boolean> getGaloisConn() {
		return galois;
	}

	public int getPartialOpCount() {
		return partialops.size();
	}

	public void add(final PartialOperation<Boolean> op) {
		assert op.getSize() == size && op.isPartialOperation();

		partialops.add(op);

		final Tensor<Boolean> t0 = galois.getTensor();
		final Tensor<Boolean> t1 = Tensor.generate(partialops.size(), new Func1<Boolean, Integer>() {
			@Override
			public Boolean call(Integer elem) {
				PartialOperation<Boolean> op2 = partialops.get(elem);
				// System.out.println(PartialOperation.format(op));
				// System.out.println(PartialOperation.format(op2));
				Boolean b = op.commutes(op2);
				assert b.equals(op2.commutes(op));
				// System.out.println();
				return b;
			}
		});

		Tensor<Boolean> t2 = Tensor.generate(partialops.size(), partialops.size(),
			new Func2<Boolean, Integer, Integer>() {
				@Override
				public Boolean call(Integer elem1, Integer elem2) {
					if (elem1 < partialops.size() - 1 && elem2 < partialops.size() - 1)
						return t0.getElem(elem1, elem2);
					else
						return t1.getElem(Math.min(elem1, elem2));
				}
			});

		galois = GaloisConn.wrap(t2);
	}

	public <BOOL> Relation<BOOL> commutingOps(final BoolAlgebra<BOOL> alg, final PartialOperation<BOOL> op) {
		Tensor<BOOL> tensor = Tensor.generate(alg.getType(), partialops.size(), new Func1<BOOL, Integer>() {
			@Override
			public BOOL call(Integer elem) {
				PartialOperation<BOOL> op2 = PartialOperation.lift(alg, partialops.get(elem));
				return op2.commutes(op);
			}
		});
		return new Relation<BOOL>(alg, tensor);
	}

	/*
	 * Ensures that all closed sets of the selected partial operations in a join
	 * irreducible partial clone (defined by the polarity of a single partial
	 * operation) is definable by the selected partial operations.
	 */
	public boolean addCriticalOp(int arity1, int arity2) {
		assert arity1 >= 0 && arity2 >= 0;

		SatProblem problem = new SatProblem(Util.createShape(size, arity1 + 1), Util.createShape(size, arity2 + 1)) {
			@Override
			public <BOOL> BOOL compute(BoolAlgebra<BOOL> alg, List<Tensor<BOOL>> tensors) {
				PartialOperation<BOOL> op0 = new PartialOperation<BOOL>(alg, tensors.get(0));
				PartialOperation<BOOL> op1 = new PartialOperation<BOOL>(alg, tensors.get(1));
				GaloisConn<BOOL> gal = GaloisConn.lift(alg, galois);

				BOOL b = op0.isPartialOperation();
				b = alg.and(b, op1.isPartialOperation());

				b = alg.and(b, op0.isPermuteMinimal());
				b = alg.and(b, op1.isPermuteMinimal());

				b = alg.and(b, alg.not(op0.commutes(op1)));

				Relation<BOOL> set = gal.leftClosure(commutingOps(alg, op0));
				b = alg.and(b, set.isSubsetOf(commutingOps(alg, op1)));

				return b;
			}
		};

		List<Tensor<Boolean>> sol = problem.solveOne(solver);
		if (sol == null)
			return false;

		PartialOperation<Boolean> op = PartialOperation.wrap(sol.get(0));
		if (trace) {
			System.out.println(PartialOperation.format(op));
			System.out.println(PartialOperation.format(PartialOperation.wrap(sol.get(1))));
		}

		add(op);
		return true;
	}

	/*
	 * Ensures, that every meet irreducible partial clone (the polarity of a
	 * single partial operation) is generated by some subset of selected partial
	 * operations.
	 */
	public boolean addCriticalOp2(int arity1, int arity2) {
		assert arity1 >= 0 && arity2 >= 0;

		SatProblem problem = new SatProblem(Util.createShape(size, arity1 + 1), Util.createShape(size, arity2 + 1),
			Util.createShape(size, arity2 + 1)) {
			@Override
			public <BOOL> BOOL compute(BoolAlgebra<BOOL> alg, List<Tensor<BOOL>> tensors) {
				PartialOperation<BOOL> op0 = new PartialOperation<BOOL>(alg, tensors.get(0));
				PartialOperation<BOOL> op1 = new PartialOperation<BOOL>(alg, tensors.get(1));
				PartialOperation<BOOL> op2 = new PartialOperation<BOOL>(alg, tensors.get(2));

				BOOL b = op0.isPartialOperation();
				b = alg.and(b, op1.isPartialOperation());
				b = alg.and(b, op2.isPartialOperation());

				b = alg.and(b, op0.isPermuteMinimal());
				b = alg.and(b, op1.isPermuteMinimal());
				b = alg.and(b, op2.isPermuteMinimal());

				b = alg.and(b, op0.commutes(op1));
				b = alg.and(b, alg.not(op0.commutes(op2)));

				Relation<BOOL> set1 = commutingOps(alg, op1);
				Relation<BOOL> set2 = commutingOps(alg, op2);
				b = alg.and(b, set1.isSubsetOf(set2));

				return b;
			}
		};

		List<Tensor<Boolean>> sol = problem.solveOne(solver);
		if (sol == null)
			return false;

		PartialOperation<Boolean> op = PartialOperation.wrap(sol.get(0));
		if (trace)
			System.out.println(PartialOperation.format(op));

		add(op);
		return true;
	}

	public void generate(int arity1, int arity2) {
		assert arity1 >= 1 && arity2 >= 1;

		if (trace)
			System.out.println("critical ops of type 2:");
		for (int i = 1; i <= arity1; i++)
			while (addCriticalOp2(i, arity2))
				;

		if (trace)
			System.out.println("critical ops of type 1:");
		for (int i = 1; i <= Math.max(arity1, arity2); i++)
			while (addCriticalOp(Math.min(i, arity1), Math.min(i, arity2)))
				;
	}

	public List<Relation<Boolean>> getClosedSets(int limit) {
		return GaloisConn.findLeftClosedSets(solver, galois, limit);
	}

	public void print() {
		System.out.println("structural clone interval on universe " + size);

		System.out.println("partial operations: " + partialops.size());
		int c = 0;
		for (PartialOperation<Boolean> op : partialops)
			System.out.println((c++) + ":\t" + PartialOperation.format(op));

		GaloisConn.print(galois);
	}

	public void printClosedSets(int limit) {
		List<Relation<Boolean>> sets = getClosedSets(limit);
		System.out.println("closed sets of partial ops: " + (sets.size() == limit ? ">=" : "") + sets.size());

		for (int i = 0; i < sets.size(); i++)
			System.out.println(i + ":\t" + Relation.format(sets.get(i)));
	}

	public static void main(String[] args) {
		StructuralClones clones = new StructuralClones(2);
		clones.trace = true;
		clones.generate(1, 1);
		clones.print();
		clones.printClosedSets(-1);
	}
}
